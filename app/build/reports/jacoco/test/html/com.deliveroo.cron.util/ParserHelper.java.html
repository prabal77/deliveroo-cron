<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParserHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app</a> &gt; <a href="index.source.html" class="el_package">com.deliveroo.cron.util</a> &gt; <span class="el_source">ParserHelper.java</span></div><h1>ParserHelper.java</h1><pre class="source lang-java linenums">package com.deliveroo.cron.util;

import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.deliveroo.cron.model.CronFieldType;

/**
 * Exposes logic to parse Cron field expression string and return list of valid values
 *
 * @author nandip
 * @since 19-Jun-2022
 **/
<span class="nc" id="L21">public class ParserHelper {</span>
<span class="fc" id="L22">    private static final Logger log = LoggerFactory.getLogger(ParserHelper.class);</span>
    private static final String GLOBAL_INVALID_CHARACTER_REGEX = &quot;[^a-zA-Z0-9\\*\\/\\-\\?\\#]+&quot;;

    /**
     * Parse the input string of type {@link com.deliveroo.cron.model.CronField} type and return list of valid values
     *
     * @param cronFieldType cron field type
     * @param input         input string
     * @return immutable list of valid values
     */
    public static List&lt;Integer&gt; parseCronField(CronFieldType cronFieldType, String input) {
        // Validate against whitelisted characters
<span class="fc bfc" id="L34" title="All 2 branches covered.">        if (containsInValidCharacters(input)) {</span>
<span class="fc" id="L35">            throw new IllegalArgumentException(&quot;Input &quot; + input + &quot; for cron field type &quot; + cronFieldType.name() + &quot; contains illegal characters&quot;);</span>
        }
        // Trim string for any extra spaces
<span class="fc" id="L38">        String[] inputFragments = extractAllFragments(input.trim());</span>
        // Use tree set to maintain natural order of output and remove duplicates
<span class="fc" id="L40">        TreeSet&lt;Integer&gt; output = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L41" title="All 2 branches covered.">        for (String fragment : inputFragments) {</span>
<span class="pc bpc" id="L42" title="1 of 3 branches missed.">            switch (cronFieldType) {</span>
                case MINUTE:
                case HOUR:
                case DAY_OF_MONTH: {
<span class="fc" id="L46">                    output.addAll(parseNumericOnlyFields(cronFieldType, cronFieldType.getMin(), cronFieldType.getMax(), fragment));</span>
<span class="fc" id="L47">                    break;</span>
                }
                case MONTH:
                case DAY_OF_WEEK: {
<span class="fc" id="L51">                    output.addAll(parseAlphanumericFields(cronFieldType, cronFieldType.getMin(), cronFieldType.getMax(), fragment));</span>
                    break;
                }
            }
        }
<span class="fc" id="L56">        return output.stream().collect(Collectors.toUnmodifiableList());</span>
    }

    /**
     * Check if the input fragment contains any invalid character.
     * White listed characters: [a-zA-Z], numeric values [0-9], special characters [&quot;*&quot;, &quot;/&quot;, &quot;-&quot;, &quot;?&quot;, &quot;#&quot;]
     * Any other character/special character is considered invalid
     *
     * @param inputFragment
     * @return true if input contains invalid character
     */
    private static boolean containsInValidCharacters(String inputFragment) {
<span class="fc" id="L68">        return inputFragment.matches(GLOBAL_INVALID_CHARACTER_REGEX);</span>
    }

    /**
     * Extract all input fragments from the input expression. Each input fragment denotes valid cron field separated by &quot;,&quot;
     *
     * @param input input cron field string
     * @return array of input fragments
     */
    private static String[] extractAllFragments(String input) {
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (input.indexOf(&quot;,&quot;) != -1) {</span>
<span class="fc" id="L79">            return input.split(&quot;,&quot;);</span>
        } else {
<span class="fc" id="L81">            return new String[]{input};</span>
        }
    }

    /**
     * Parse the input fragment and returns all possible allowed values within the min and max range, as a set of integers.
     * Applicable only for numeric only fields i.e. minute, hour and day of month.
     * Performs following operations
     * &lt;br/&gt;
     * &lt;b&gt;Note: Uses multiple regex, instead of single. As this makes the code stable and less error prone due to indexing problems&lt;/b&gt;
     * &lt;br/&gt;
     * &lt;ul&gt;
     *     &lt;li&gt;If input is '*' then returns all values in range (min and max) both including&lt;/li&gt;
     *     &lt;li&gt;If input is single numeric value, return the value (if within the range)&lt;/li&gt;
     *     &lt;li&gt;If input is range, returns all valid values within the range (both inclusive)&lt;/li&gt;
     *     &lt;li&gt;If input is step function, returns values starting from min to max, incremented by step value&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param cronFieldType - Type of cron field function is parsing
     * @param minValue      - Min value defined for the field
     * @param maxValue      - Max value defined for the field
     * @param inputFragment - user input string fragment
     * @return set of all possible valid values
     */
    private static Set&lt;Integer&gt; parseNumericOnlyFields(CronFieldType cronFieldType, int minValue, int maxValue, String inputFragment) {
        // Test All value pattern first
<span class="fc" id="L107">        Matcher matcher = RegexExpressions.ALL_VALUES_PATTERN.matcher(inputFragment);</span>
        // If matches all value pattern
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="fc" id="L110">            return FragmentHandler.handleAllValuePatternMatch(minValue, maxValue);</span>
        }
        // if matches only integer pattern
<span class="fc" id="L113">        matcher = RegexExpressions.ONLY_NUMERIC_PATTERN.matcher(inputFragment);</span>
        // If matches all value pattern
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="fc" id="L116">            return Set.of(FragmentHandler.handleSingleNumericMatch(matcher.group(), minValue, maxValue));</span>
        }
        // if matches only numeric range pattern
<span class="fc" id="L119">        matcher = RegexExpressions.ONLY_NUMERIC_RANGE_PATTERN.matcher(inputFragment);</span>
        // If matches all value pattern
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="fc" id="L122">            return FragmentHandler.handleNumericRangePatternMatch(matcher.group(1), matcher.group(2), minValue, maxValue);</span>
        }
        // if matches only numeric step pattern
<span class="fc" id="L125">        matcher = RegexExpressions.ONLY_NUMERIC_STEP_PATTERN.matcher(inputFragment);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (matcher.matches()) {</span>
            String start;
            String end;
            // parse the range portion of the step function
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (Objects.equals(&quot;*&quot;, matcher.group(1))) {</span>
                // If step start-end range is &quot;*&quot; (ALL values)
<span class="fc" id="L132">                start = String.valueOf(minValue);</span>
<span class="fc" id="L133">                end = String.valueOf(maxValue);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            } else if (Objects.isNull(matcher.group(2))) {</span>
                // Step range is single value
<span class="fc" id="L136">                start = matcher.group(1);</span>
<span class="fc" id="L137">                end = String.valueOf(maxValue);</span>
            } else {
                // Step range is numeric range
<span class="fc" id="L140">                start = matcher.group(2);</span>
<span class="fc" id="L141">                end = matcher.group(3);</span>
            }
<span class="fc" id="L143">            return FragmentHandler.handleStepPatternMatch(start, end, matcher.group(4), minValue, maxValue);</span>
        }
<span class="fc" id="L145">        throw new IllegalArgumentException(&quot;Invalid input for field type &quot; + cronFieldType.name() + &quot; input &quot; + inputFragment);</span>
    }

    /**
     * Parse the input fragment and returns all possible allowed values within the min and max range, as a set of integers.
     * Applicable only for alphanumeric field only i.e. month and day of week
     * Performs following operations
     * &lt;br/&gt;
     * &lt;b&gt;Note: Uses multiple regex, instead of single. As this makes the code stable and less error prone due to indexing problems&lt;/b&gt;
     * &lt;br/&gt;
     * &lt;ul&gt;
     *     &lt;li&gt;If input is '*' then returns all values in range (min and max) both including&lt;/li&gt;
     *     &lt;li&gt;If input is single numeric value, return the value (if within the range)&lt;/li&gt;
     *     &lt;li&gt;If input is range, returns all valid values within the range (both inclusive)&lt;/li&gt;
     *     &lt;li&gt;If input is step function, returns values starting from min to max, incremented by step value&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param cronFieldType - Type of cron field function is parsing
     * @param minValue      - Min value defined for the field
     * @param maxValue      - Max value defined for the field
     * @param inputFragment - user input string fragment
     * @return set of all possible valid values
     */
    private static Set&lt;Integer&gt; parseAlphanumericFields(CronFieldType cronFieldType, int minValue, int maxValue, String inputFragment) {
        // Test All value pattern first
<span class="fc" id="L170">        Matcher matcher = RegexExpressions.ALL_VALUES_PATTERN.matcher(inputFragment);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="fc" id="L172">            return FragmentHandler.handleAllValuePatternMatch(minValue, maxValue);</span>
        }
        // if matches only integer pattern
<span class="fc" id="L175">        matcher = RegexExpressions.ONLY_NUMERIC_PATTERN.matcher(inputFragment);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="fc" id="L177">            return Set.of(FragmentHandler.handleSingleNumericMatch(matcher.group(), minValue, maxValue));</span>
        }
        // if matches only single word pattern
<span class="fc" id="L180">        matcher = RegexExpressions.ONLY_ALPHABET_PATTERN.matcher(inputFragment);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="nc" id="L182">            return Set.of(FragmentHandler.handleOnlyAlphabetPatternMatch(cronFieldType, matcher.group(), minValue, maxValue));</span>
        }
        // if matches only numeric range pattern
<span class="fc" id="L185">        matcher = RegexExpressions.ALPHANUMERIC_RANGE_PATTERN.matcher(inputFragment);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="fc" id="L187">            String start = matcher.group(1);</span>
<span class="fc" id="L188">            String end = matcher.group(2);</span>
            // if start and end are integer, return, else look up the integer value of the String passed
<span class="fc bfc" id="L190" title="All 2 branches covered.">            String startInteger = RegexExpressions.NUMERIC_ONLY_SUB_ITEM.matcher(start).matches() ? start : NameToIntegerMap.getIntegerValue(cronFieldType, start.toLowerCase()).toString();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            String endInteger = RegexExpressions.NUMERIC_ONLY_SUB_ITEM.matcher(end).matches() ? end : NameToIntegerMap.getIntegerValue(cronFieldType, end.toLowerCase()).toString();</span>
<span class="fc" id="L192">            return FragmentHandler.handleNumericRangePatternMatch(startInteger, endInteger, minValue, maxValue);</span>
        }

        // if matches alphanumeric step pattern
<span class="fc" id="L196">        matcher = RegexExpressions.ALPHANUMERIC_STEP_PATTERN.matcher(inputFragment);</span>
        // If matches all value pattern
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (matcher.matches()) {</span>
            String start;
            String end;
<span class="fc" id="L201">            String step = matcher.group(4);</span>
            // parse the range portion of the step function
<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (Objects.equals(&quot;*&quot;, matcher.group(1))) {</span>
                // If step start-end range is &quot;*&quot; (ALL values)
<span class="fc" id="L205">                start = String.valueOf(minValue);</span>
<span class="fc" id="L206">                end = String.valueOf(maxValue);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            } else if (Objects.isNull(matcher.group(2))) {</span>
                // Step range is single value (handles numeric and word both)
<span class="fc bfc" id="L209" title="All 2 branches covered.">                start = RegexExpressions.NUMERIC_ONLY_SUB_ITEM.matcher(matcher.group(1)).matches() ? matcher.group(1) : NameToIntegerMap.getIntegerValue(cronFieldType, matcher.group(1).toLowerCase()).toString();</span>
<span class="fc" id="L210">                end = String.valueOf(maxValue);</span>
            } else {
                // Step range is numeric range
<span class="fc" id="L213">                String startValue = matcher.group(2);</span>
<span class="fc" id="L214">                String endValue = matcher.group(3);</span>
<span class="fc" id="L215">                String stepValue = matcher.group(4);</span>
                // if start and end are integer, return else look up the integer value of the String passed
<span class="fc bfc" id="L217" title="All 2 branches covered.">                start = RegexExpressions.NUMERIC_ONLY_SUB_ITEM.matcher(startValue).matches() ? startValue : NameToIntegerMap.getIntegerValue(cronFieldType, startValue.toLowerCase()).toString();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">                end = RegexExpressions.NUMERIC_ONLY_SUB_ITEM.matcher(endValue).matches() ? endValue : NameToIntegerMap.getIntegerValue(cronFieldType, endValue.toLowerCase()).toString();</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                step = RegexExpressions.NUMERIC_ONLY_SUB_ITEM.matcher(stepValue).matches() ? stepValue : NameToIntegerMap.getIntegerValue(cronFieldType, stepValue.toLowerCase()).toString();</span>
            }
<span class="fc" id="L221">            return FragmentHandler.handleStepPatternMatch(start, end, step, minValue, maxValue);</span>
        }
<span class="nc" id="L223">        throw new IllegalArgumentException(&quot;Invalid input for field type &quot; + cronFieldType.name() + &quot; input &quot; + inputFragment);</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>